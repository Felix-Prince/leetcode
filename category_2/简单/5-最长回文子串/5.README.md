# 题解

## 暴力破解

详细代码见 `5-1.js`

暴力破解就是直接便利字符串的长度，然后挨个去比较截取子串判断是否回文，但是在 leetcode 中提交是超时的，但是根据超时的那个字符串发现，貌似他是个相同字符组成的长串，那我是不是可以单独考虑这种情况呢，因此就增加了如下的代码

```js
var ss = Array.from(new Set(s.split("")));
if (ss.length == 1) return s;
```

我先排除这种极端情况，这种极端情况我就直接返回原串，这样处理后通过了，但是运行事件都是在 1500+ms，这里并不推荐这做法

## 中心扩散法

思路：
遍历每一个字符，判断以这个字符作为中心时的最长回文子串，以及判断以这个字符之后的空隙作为中心时的最长回文子串（偶数长度）
同样是有两个指针，奇数长度时，指向同一个字符，偶数长度时，指向当前字符和当前位置+1 处的字符，当满足条件时就会移动指针，并且判断此次截取的子串是不是最长的，记录最长子串的开始位置
这样就能截取处最长的回文子串了

> 补充内容

位运算符
左移 `<<` 右移 `>>`

左移相当于 `*2`，右移相当于 `/2`

```js
// 左移
a = 00000011; // 十进制3
a << 4; // 00110000 (十进制48) ==> 3 * 2 * 2 * 2 * 2
// 右移
a = 000001111; // 十进制15
a >> 2; //  00000011(十进制3) 15 / 2 / 2
```
